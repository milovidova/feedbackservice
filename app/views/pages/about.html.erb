
<div class='firstblock'>
<p class="first">Fresh Eye Design</p>
<p class="longtext">
Замылился глаз и не видно очевидных ошибок? <br> Получите объективную оценку от коллег и уверенно сдавайте работу, зная, что всё на высшем уровне.

</p>
</div>
  
<%= image_tag "bluecomment.svg", class: "comment2" %>



   <h1 class="main-title">
    <span class="line">
      <span class="char">У</span><span class="char">л</span><span class="char">у</span><span class="char">ч</span><span class="char">ш</span><span class="char">а</span><span class="char">й</span>

      <span class="char">с</span><span class="char">е</span><span class="char">б</span><span class="char">я,</span>
    </span>
    <span class="line">
      <span class="char">п</span><span class="char">о</span><span class="char">м</span><span class="char">о</span><span class="char">г</span><span class="char">и</span>

      <span class="char">д</span><span class="char">р</span><span class="char">у</span><span class="char">г</span><span class="char">и</span><span class="char">м.</span>
    </span>
  </h1>
</div>

   
    <div class='new'
    <section class="animation-section" id="animationBlock">
        <div class="animation-container">
            <div class="moving-text" id="animatedText">
                Покажите работу, которая требует взгляда со стороны. Укажите контекст, <br> чтобы получить релевантные советы.
            </div>
               
        </div>
    </section>
  <section class="animation-section" id="animationBlock2">
        <div class="animation-container">
       <div class="moving-text2" id="animatedText2">
             <p style="white-space: pre">Дизайнеры из сообщества дадут вам честную и конструктивную оценку <br>по композиции, типографике и usability.           Помогите коллегам и зарабатывайте баллы, чтобы ваши работы получали <br>                                                                                     больше просмотров и ответов.</p>
            </div>
        </div>
    </section>
       <section class="animation-section" id="animationBlock3">
        <div class="animation-container">
            <div class="moving-text3" id="animatedText3">
                Больше не нужно гадать, "нормально <br> ли это"
            </div>
               
        </div>
    </section>
      <section class="animation-section" id="animationBlock4">
        <div class="animation-container">
       <div class="moving-text4" id="animatedText4">
   
                Получайте уверенность <br> в каждой детали
            </div>
        </div>
    </section>
      </div>


      <p class='smalltext'> 
        Сдавайте проекты,<br> которые не стыдно <br> положить в портфолио.
</p>



<div class="pixel-grid" id="pixelGrid"></div>
<div class="pixel-grid2" id="pixelGrid2"></div>
<div class="pixel-grid3" id="pixelGrid3"></div>
   <p class='smalltext2'> 
        Это не просто «нравится/не нравится», <br>а структурированная и аргументированная помощь<br>от таких же практикующих специалистов.
</p>


 <p class='smalltext3'> 
Получите экспертное мнение в вашей нише
</p>


<div class='rects'>
<div class='firstrect'>
<%= image_tag "firstrect.png", class: "firstrectpng" %>
<p class='firsttextrect'> 
веб-дизайн
</p>
<p class='firsttextrect2'> 
сайты
</p><p class='firsttextrect3'> 
Получите совет <br>
по юзабилити и общему <br> визуальному впечатлению
</p>
</div>

<div class='firstrect'>
<%= image_tag "secondrect.png", class: "firstrectpng" %>
<p class='firsttextrect'> 
графический дизайн
</p>
<p class='firsttextrect2'> 
айдентика
</p><p class='firsttextrect3'> 
Фирменный стиль, полиграфия <br> — здесь ценят работу с формой <br> и смыслом.
</p>
</div>

<div class='firstrect'>
<%= image_tag "thirdrect.png", class: "firstrectpng" %>
<p class='firsttextrect'> 
UI/UX дизайн
</p>
<p class='firsttextrect2'> 
интерфейсы
</p><p class='firsttextrect3'> 
Получите фидбек на удобство,<br> расстановку акцентов <br>
и ясность элементов
</p>
</div>
</div>

<div id="cursor-area">
  <div class='fiveblock'>
    <div class='fivetext'>
      <p class='smalltext4'> 
        Покажите проект коллегам и получите <br> фидбек, который поможет ему вырасти
      </p>
      <div class='load'>
        <p class='smalltext4'> 
          Типографика
        </p>
        <p class='smalltext4'> 
          Цвет
        </p>
        <p class='smalltext4'> 
          Композиция
        </p>
      </div>
    </div>
    <%= image_tag "loading.svg", class: "loading" %>
    <div class='threeimarrow'>
      <div class='threeim'>
        <div class='whiterect1'>
          <%= image_tag "blue.png", class: "bluepng draggable" %>
        </div>
        <div class='whiterect2'>
          <%= image_tag "burger.png", class: "burgerpng draggable" %>
        </div>
        <div class='whiterect3'>
          <%= image_tag "gray.png", class: "graypng draggable" %>
        </div>
        <%= image_tag "blackarrow.svg", class: "blackarrowsvg" %>
      </div>
    </div>
  </div>
</div>

<p class='feedback'>Получай <br>фидбек</p>
<div class='firstsecim'>
<div class='firstsec'>
<div class='sixsection'>
<p class='designer1'>Дизайнер 1</p>
</div>
<p class='feedbacktext'>на боковой стороне можно добавить небольшой графический элемент (например, корону или иконку бургера)</p>
</div>
<div class='burgersect'>
<%= image_tag "whiteburger.png", class: "whiteburgerpng" %>
<%= image_tag "color.svg", class: "colorsvg" %>
</div>
<div class='firstsec2'>
<div class='sixsection'>
<p class='designer1'>Дизайнер 2</p>
</div>
<p class='feedbacktext'>
на белом цвете  будут сильно заметны следы 
<br>от жира 
или пальцев</p>
</div>
</div>

<p class='contacts'>контакты</p>
<div class='grayline'>   
</div>
<div class='futer1'>   
<p class='firstfuter'>FreshEye</p>
<div class='futer2'>   
  
<p class='secondfuter'>fresheye@mail.ru</p>
<p class='thirdfuter'>
Телеграм канал<br>
freshEyeee
</p>
</div>
<div class='futer3'>   
  
<p class='fourfuter'>
Куратор<br>
Ноздрин Федор
Дизайнер
Миловидова Нина</p>
</div>
</div>
<p class='big'>fresheye</p>


<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const chars = document.querySelectorAll('.char');
  

  gsap.set(chars, {
    opacity: 0,
    x: () => gsap.utils.random(-300, 300),
    y: () => gsap.utils.random(-150, 150),
    rotation: () => gsap.utils.random(-20, 20),
    scale: 0.5
  });
  

  const tl = gsap.timeline({
    delay: 0.5,
    defaults: { duration: 1.2, ease: "back.out(1.7)" }
  });
  
  tl.to(chars, {
    opacity: 1,
    x: 0,
    y: 0,
    rotation: 0,
    scale: 1,
    stagger: {
      amount: 1.8,
      from: "random"
    }
  });
});
</script>

<script>
class BlockScrollAnimation {
    constructor() {
        this.textElement = document.getElementById('animatedText');
        this.animationBlock = document.getElementById('animationBlock');
        this.isInView = false;
        
        this.init();
    }
    
    init() {
        window.addEventListener('scroll', this.handleScroll.bind(this));
        window.addEventListener('resize', this.handleScroll.bind(this));
        
     
        this.handleScroll();
    }
    
    handleScroll() {
        const blockRect = this.animationBlock.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        
        
        const blockTop = blockRect.top;
        const blockBottom = blockRect.bottom;
        

        this.isInView = blockTop < windowHeight && blockBottom > 0;
        
        if (this.isInView) {
            this.updateTextPosition();
        } else {

            this.textElement.style.transform = 'translateX(0) translateY(-50%)';
        }
    }
    
    updateTextPosition() {
        const blockRect = this.animationBlock.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        
  
        const blockTop = blockRect.top;
        const blockHeight = blockRect.height;
        
        let progress = 1 - (blockTop + blockHeight) / (windowHeight + blockHeight);
        progress = Math.max(0, Math.min(1, progress)); // Ограничиваем от 0 до 1
        

        const containerWidth = this.animationBlock.offsetWidth;
        const textWidth = this.textElement.offsetWidth;
        const maxMove = containerWidth - textWidth;
        const newPosition = progress * maxMove;
        
       
        this.textElement.style.transform = `translateX(${newPosition}px) translateY(-50%)`;
    }
}


document.addEventListener('DOMContentLoaded', () => {
    new BlockScrollAnimation();
});
</script>

<script>
class BlockScrollAnimation2 {
    constructor() {
        this.textElement2 = document.getElementById('animatedText2');
        this.animationBlock2 = document.getElementById('animationBlock2');
        this.isInView = false;
        
        this.init();
    }
    
    init() {
        window.addEventListener('scroll', this.handleScroll.bind(this));
        window.addEventListener('resize', this.handleScroll.bind(this));
        
        
        this.handleScroll();
    }
    
    handleScroll() {
        const blockRect = this.animationBlock2.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        
     
        const blockTop = blockRect.top;
        const blockBottom = blockRect.bottom;
        

        this.isInView = blockTop < windowHeight && blockBottom > 0;
        
        if (this.isInView) {
            this.updateTextPosition();
        } else {
         
            this.textElement2.style.transform = 'translateX(0) translateY(-50%)';
        }
    }
    
    updateTextPosition() {
        const blockRect = this.animationBlock2.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        
    
        const blockTop = blockRect.top;
        const blockHeight = blockRect.height;
        
        let progress = 1 - (blockTop + blockHeight) / (windowHeight + blockHeight);
        progress = Math.max(0, Math.min(1, progress)); // Ограничиваем от 0 до 1
        
    
        const containerWidth = this.animationBlock2.offsetWidth;
        const textWidth = this.textElement2.offsetWidth;
        const maxMove = containerWidth - textWidth;
        const newPosition = progress * maxMove;
        

        this.textElement2.style.transform = `translateX(${newPosition}px) translateY(-50%)`;
    }
}


document.addEventListener('DOMContentLoaded', () => {
    new BlockScrollAnimation2();
});
</script>

<script>
class BlockScrollAnimation3 {
    constructor() {
        this.textElement3 = document.getElementById('animatedText3');
        this.animationBlock3 = document.getElementById('animationBlock3');
        this.isInView = false;
        
        this.init();
    }
    
    init() {
        window.addEventListener('scroll', this.handleScroll.bind(this));
        window.addEventListener('resize', this.handleScroll.bind(this));
        
        
        this.handleScroll();
    }
    
    handleScroll() {
        const blockRect = this.animationBlock3.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        
     
        const blockTop = blockRect.top;
        const blockBottom = blockRect.bottom;
        

        this.isInView = blockTop < windowHeight && blockBottom > 0;
        
        if (this.isInView) {
            this.updateTextPosition();
        } else {
         
            this.textElement2.style.transform = 'translateX(0) translateY(-50%)';
        }
    }
    
    updateTextPosition() {
        const blockRect = this.animationBlock3.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        
    
        const blockTop = blockRect.top;
        const blockHeight = blockRect.height;
        
        let progress = 1 - (blockTop + blockHeight) / (windowHeight + blockHeight);
        progress = Math.max(0, Math.min(1, progress)); // Ограничиваем от 0 до 1
        
    
        const containerWidth = this.animationBlock3.offsetWidth;
        const textWidth = this.textElement3.offsetWidth;
        const maxMove = containerWidth - textWidth;
        const newPosition = progress * maxMove;
        

        this.textElement3.style.transform = `translateX(${newPosition}px) translateY(-50%)`;
    }
}


document.addEventListener('DOMContentLoaded', () => {
    new BlockScrollAnimation3();
});
</script>


<script>
class BlockScrollAnimation4 {
    constructor() {
        this.textElement4 = document.getElementById('animatedText4');
        this.animationBlock4 = document.getElementById('animationBlock4');
        this.isInView = false;
        
        this.init();
    }
    
    init() {
        window.addEventListener('scroll', this.handleScroll.bind(this));
        window.addEventListener('resize', this.handleScroll.bind(this));
        
        
        this.handleScroll();
    }
    
    handleScroll() {
        const blockRect = this.animationBlock4.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        
     
        const blockTop = blockRect.top;
        const blockBottom = blockRect.bottom;
        

        this.isInView = blockTop < windowHeight && blockBottom > 0;
        
        if (this.isInView) {
            this.updateTextPosition();
        } else {
         
            this.textElement4.style.transform = 'translateX(0) translateY(-50%)';
        }
    }
    
    updateTextPosition() {
        const blockRect = this.animationBlock4.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        
    
        const blockTop = blockRect.top;
        const blockHeight = blockRect.height;
        
        let progress = 1 - (blockTop + blockHeight) / (windowHeight + blockHeight);
        progress = Math.max(0, Math.min(1, progress)); // Ограничиваем от 0 до 1
        
    
        const containerWidth = this.animationBlock4.offsetWidth;
        const textWidth = this.textElement4.offsetWidth;
        const maxMove = containerWidth - textWidth;
        const newPosition = progress * maxMove;
        

        this.textElement4.style.transform = `translateX(${newPosition}px) translateY(-50%)`;
    }
}


document.addEventListener('DOMContentLoaded', () => {
    new BlockScrollAnimation4();
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  function createPixelGrid() {
    const grid = document.getElementById('pixelGrid');
    
    for (let i = 0; i < 100; i++) {
      const pixel = document.createElement('div');
      pixel.className = 'pixel';
      grid.appendChild(pixel);
    }
  }

  function loadImageToPixels(imageUrl) {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = imageUrl;
    
    img.onload = function() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const pixels = document.querySelectorAll('.pixel');
      
      canvas.width = 10;
      canvas.height = 10;

      ctx.drawImage(img, 0, 0, 10, 10);
      
      const imageData = ctx.getImageData(0, 0, 10, 10);
      const data = imageData.data;
      
      pixels.forEach((pixel, index) => {
        const x = index % 10;
        const y = Math.floor(index / 10);
        const pixelIndex = (y * 10 + x) * 4;
        
        const r = data[pixelIndex];
        const g = data[pixelIndex + 1];
        const b = data[pixelIndex + 2];
        
        pixel.style.background = `rgb(${r}, ${g}, ${b})`;
      });
      
      const overlayImg = document.createElement('img');
      overlayImg.src = imageUrl;
      overlayImg.className = 'image-overlay';
      document.getElementById('pixelGrid').appendChild(overlayImg);
      
      window.addEventListener('scroll', revealImage);
    };
    

    img.onerror = function() {
      console.error('Ошибка загрузки изображения:', imageUrl);
    };
  }

  function revealImage() {
    const grid = document.getElementById('pixelGrid');
    const position = grid.getBoundingClientRect();
    const overlayImg = document.querySelector('.image-overlay');
    
    if (position.top < window.innerHeight - 100) {
      const pixels = document.querySelectorAll('.pixel');
      pixels.forEach((pixel, index) => {
        setTimeout(() => {
          pixel.style.opacity = '0';
        }, index * 10);
      });
      
      overlayImg.style.opacity = '1';
      window.removeEventListener('scroll', revealImage);
    }
  }


  createPixelGrid();
  loadImageToPixels('<%= asset_path("ffirstimage.png") %>');
});
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  function createPixelGrid2() {
    const grid = document.getElementById('pixelGrid2');
    
    for (let i = 0; i < 100; i++) {
      const pixel2 = document.createElement('div');
      pixel2.className = 'pixel2';
      grid.appendChild(pixel2);
    }
  }

  function loadImageToPixels(imageUrl) {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = imageUrl;
    
    img.onload = function() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const pixels = document.querySelectorAll('.pixel2');
      
      canvas.width = 10;
      canvas.height = 10;

      ctx.drawImage(img, 0, 0, 10, 10);
      
      const imageData = ctx.getImageData(0, 0, 10, 10);
      const data = imageData.data;
      
      pixels.forEach((pixel2, index) => {
        const x = index % 10;
        const y = Math.floor(index / 10);
        const pixelIndex = (y * 10 + x) * 4;
        
        const r = data[pixelIndex];
        const g = data[pixelIndex + 1];
        const b = data[pixelIndex + 2];
        
        pixel2.style.background = `rgb(${r}, ${g}, ${b})`;
      });
      
      const overlayImg = document.createElement('img');
      overlayImg.src = imageUrl;
      overlayImg.className = 'image-overlay2';
      document.getElementById('pixelGrid2').appendChild(overlayImg);
      
      window.addEventListener('scroll', revealImage);
    };


    img.onerror = function() {
      console.error('Ошибка загрузки изображения:', imageUrl);
    };
  }

  function revealImage() {
    const grid = document.getElementById('pixelGrid2');
    const position = grid.getBoundingClientRect();
    const overlayImg = document.querySelector('.image-overlay2');
    
    if (position.top < window.innerHeight - 100) {
      const pixels = document.querySelectorAll('.pixel2');
      pixels.forEach((pixel2, index) => {
        setTimeout(() => {
          pixel2.style.opacity = '0';
        }, index * 10);
      });
      
      overlayImg.style.opacity = '1';
      window.removeEventListener('scroll', revealImage);
    }
  }

  
  createPixelGrid2();
  loadImageToPixels('<%= asset_path("upac.png") %>');
});
</script>
<script>
function createPixelGrid3() {
  const grid = document.getElementById('pixelGrid3');
  
  for (let i = 0; i < 100; i++) {
    const pixel3 = document.createElement('div');
    pixel3.className = 'pixel3';
    grid.appendChild(pixel3);
  }
}

function loadImageToPixels(imageUrl) {
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.src = imageUrl;
  
  img.onload = function() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const pixels = document.querySelectorAll('.pixel3');
    
    canvas.width = 10;
    canvas.height = 10;

    ctx.drawImage(img, 0, 0, 10, 10);
    
    const imageData = ctx.getImageData(0, 0, 10, 10);
    const data = imageData.data;
    
    pixels.forEach((pixel3, index) => { 
      const x = index % 10;
      const y = Math.floor(index / 10);
      const pixelIndex = (y * 10 + x) * 4;
      
      const r = data[pixelIndex];
      const g = data[pixelIndex + 1];
      const b = data[pixelIndex + 2];
      
      pixel3.style.background = `rgb(${r}, ${g}, ${b})`; 
    });
    
    const overlayImg = document.createElement('img');
    overlayImg.src = imageUrl;
    overlayImg.className = 'image-overlay3';
    document.getElementById('pixelGrid3').appendChild(overlayImg);
    
    window.addEventListener('scroll', revealImage);
  };
}

function revealImage() {
  const grid = document.getElementById('pixelGrid3');
  const position = grid.getBoundingClientRect();
  const overlayImg = document.querySelector('.image-overlay3');
  
  if (position.top < window.innerHeight - 100) {
    const pixels = document.querySelectorAll('.pixel3');
    pixels.forEach((pixel3, index) => {
      setTimeout(() => {
        pixel3.style.opacity = '0';
      }, index * 10);
    });
    
    overlayImg.style.opacity = '1';
    window.removeEventListener('scroll', revealImage);
  }
}

createPixelGrid3();
loadImageToPixels('<%= asset_path("paketgreen.png") %>');
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const area = document.getElementById('cursor-area');
  const cursor = document.createElement('img');
  
 
  cursor.src = '<%= asset_path('hand2.png') %>';
  cursor.style.position = 'fixed';
  cursor.style.width = '276px';  
  cursor.style.height = '468px'; 
  cursor.style.pointerEvents = 'none';
  cursor.style.zIndex = '9999';
  cursor.style.display = 'none';
  cursor.style.objectFit = 'contain'; 
  
  document.body.appendChild(cursor);
  
  area.addEventListener('mouseenter', function() {
    cursor.style.display = 'block';
    document.body.style.cursor = 'none';
  });
  
  area.addEventListener('mousemove', function(e) {
   
    cursor.style.left = (e.clientX - 138) + 'px'; 
    cursor.style.top = (e.clientY - 234) + 'px';  
  });
  
  area.addEventListener('mouseleave', function() {
    cursor.style.display = 'none';
    document.body.style.cursor = 'auto';
  });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const draggableElements = document.querySelectorAll('.draggable');
  
  draggableElements.forEach(element => {
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;
    
 
    element.addEventListener('mousedown', dragStart);
    element.addEventListener('touchstart', dragStart);
    
    
    document.addEventListener('mousemove', drag);
    document.addEventListener('touchmove', drag);
    

    document.addEventListener('mouseup', dragEnd);
    document.addEventListener('touchend', dragEnd);
    
    function dragStart(e) {
      if (e.type === 'touchstart') {
        initialX = e.touches[0].clientX - xOffset;
        initialY = e.touches[0].clientY - yOffset;
      } else {
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;
      }
      
      if (e.target === element) {
        isDragging = true;
        element.classList.add('dragging');
        

        element.style.zIndex = '1000';
        element.style.position = 'relative';
      }
    }
    
    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        
        if (e.type === 'touchmove') {
          currentX = e.touches[0].clientX - initialX;
          currentY = e.touches[0].clientY - initialY;
        } else {
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
        }
        
        xOffset = currentX;
        yOffset = currentY;
        
        setTranslate(currentX, currentY, element);
      }
    }
    
    function dragEnd(e) {
      if (isDragging) {
        initialX = currentX;
        initialY = currentY;
        isDragging = false;
        element.classList.remove('dragging');
        
       
        setTimeout(() => {
          element.style.zIndex = '';
        }, 100);
      }
    }
    
    function setTranslate(xPos, yPos, el) {
      el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
    }
  });
});
</script>
